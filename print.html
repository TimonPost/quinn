<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quinn</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="network-introduction.html"><strong aria-hidden="true">1.</strong> Network Introduction</a></li><li class="chapter-item expanded "><a href="quinn.html"><strong aria-hidden="true">2.</strong> QUINN Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quinn/introduction.html"><strong aria-hidden="true">2.1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="quinn/certificate.html"><strong aria-hidden="true">2.2.</strong> Cryptography Setup</a></li><li class="chapter-item expanded "><a href="quinn/set-up-connection.html"><strong aria-hidden="true">2.3.</strong> Connection Setup</a></li><li class="chapter-item expanded "><a href="quinn/data-transfer.html"><strong aria-hidden="true">2.4.</strong> Data Transfer</a></li></ol></li><li class="chapter-item expanded "><a href="quic.html"><strong aria-hidden="true">3.</strong> QUICK Introduction</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Quinn</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#networking-introduction" id="networking-introduction">Networking Introduction</a></h1>
<p>In this chapter, you will find a very short introduction to various networking concepts. 
Those concepts are key for understanding the motivations for QUIC. </p>
<h2><a class="header" href="#1-tcpip-and-udp-comparison" id="1-tcpip-and-udp-comparison">1. TCP/IP and UDP Comparison</a></h2>
<p><strong>TCP:</strong> stands for 'transmission control protocol' and adds certain guarantees ontop of <a href="https://nl.wikipedia.org/wiki/Internetprotocol">IP</a>. 
It forms the backbone for almost everything you do online, from web browsing to IRC to email to file transfer.
The protocol is <a href="network-introduction.html#2-the-5-transport-guarantees">reliable ordered</a> in nature.</p>
<p><strong>UDP</strong> stands for 'user datagram protocol' and adds certain guarantees ontop of <a href="https://nl.wikipedia.org/wiki/Internetprotocol">IP</a>, but unlike TCP, 
instead of adding lots of features and complexity, UDP is a very thin layer over IP and is also <a href="network-introduction.html#2-the-5-transport-guarantees">unreliable</a> in nature.</p>
<table><thead><tr><th align="center">Feature</th><th align="center">TCP</th><th align="center">UDP</th><th align="center">QUIC</th></tr></thead><tbody>
<tr><td align="center"><a href="https://en.wikipedia.org/wiki/Connection-oriented_communication">Connection-Oriented</a></td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td align="center"><a href="network-introduction.html#2-the-5-transport-guarantees">Transport Guarantees</a></td><td align="center"><a href="network-introduction.html#2-the-5-transport-guarantees">Reliable Ordered</a></td><td align="center"><a href="network-introduction.html#2-the-5-transport-guarantees">Unreliable</a></td><td align="center"><a href="network-introduction.html#2-the-5-transport-guarantees">Reliable Ordered</a> and <a href="network-introduction.html#2-the-5-transport-guarantees">Unreliable</a></td></tr>
<tr><td align="center">Packet Transfer</td><td align="center"><a href="https://en.wikipedia.org/wiki/Stream_(computing)">Stream-based</a></td><td align="center">Message based</td><td align="center">Message based and Stream based</td></tr>
<tr><td align="center">Automatic <a href="https://en.wikipedia.org/wiki/IP_fragmentation">fragmentation</a></td><td align="center">Yes</td><td align="center">Yes, but better to stay below datagram size limit</td><td align="center">Yes</td></tr>
<tr><td align="center">Header Size</td><td align="center">20 bytes</td><td align="center">8 bytes</td><td align="center">16 bytes</td></tr>
<tr><td align="center"><a href="https://en.wikipedia.org/wiki/TCP_congestion_control">Control Flow, Congestion Avoidance/Control</a></td><td align="center">Yes</td><td align="center">No</td><td align="center">Yes, and user controlled</td></tr>
</tbody></table>
<h2><a class="header" href="#2-the-5-transport-guarantees" id="2-the-5-transport-guarantees">2. The 5 Transport Guarantees</a></h2>
<p>There are 5 main different ways you can transfer data:</p>
<table><thead><tr><th align="center">Transport Guarantees</th><th align="center">Packet Drop <a href="https://en.wikipedia.org/wiki/Packet_loss">(1)</a></th><th align="center">Packet Duplication <a href="https://observersupport.viavisolutions.com/html_doc/current/index.html#page/gigastor_hw/packet_deduplicating.html">(2)</a></th><th align="center">Packet Order</th><th align="center">Packet Delivery</th></tr></thead><tbody>
<tr><td align="center"><strong>Unreliable Unordered</strong></td><td align="center">Any</td><td align="center">Yes</td><td align="center">No</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Unreliable Sequenced</strong></td><td align="center">Any + old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">No</td></tr>
<tr><td align="center"><strong>Reliable Unordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">No</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Ordered</strong></td><td align="center">No</td><td align="center">No</td><td align="center">Ordered</td><td align="center">Yes</td></tr>
<tr><td align="center"><strong>Reliable Sequenced</strong></td><td align="center">Only old</td><td align="center">No</td><td align="center">Sequenced</td><td align="center">Only newest</td></tr>
</tbody></table>
<p>Unreliability gives great uncertainty with a lot of freedom, while reliability gives great certainty with costs in speed and freedom.
That is why protocols such as QUIC, RUDP, SCTP, QUIC, netcode, laminar are built on UDP instead of TCP. 
UDP gives the end-user more control over the transmission than TCP can do. </p>
<h2><a class="header" href="#3-issues-with-tcp" id="3-issues-with-tcp">3. Issues with TCP</a></h2>
<p>Now the golden question: &quot;Why choose so much uncertainty with UDP when TCP is so reliable and safe?&quot;. 
To answer that question we will have to delve a little deeper into some issues with TCP. </p>
<h3><a class="header" href="#head-of-line-blocking" id="head-of-line-blocking">Head-of-line Blocking</a></h3>
<p>One of the biggest issues with TCP is that of Head-of-line blocking. 
It is a convenient feature because it ensures that all packages are sent and arrive in <a href="network-introduction.html#2-the-5-transport-guarantees">order</a>. 
However, in cases of high throughput (multiplayer game networking) and big load in a short time (web page load), this can be catastrophic to your application performance.</p>
<p>The issue is demonstrated in the following animation:</p>
<p><img src="./images/hol.gif" alt="Head of line blocking" /> </p>
<p>This animation shows that if a certain packet drops in transmission, all packets have to wait at the transport layer until it is resent by the other end.
If the dropped packet is resent and arrived then all packets are freed from the transport layer. </p>
<p>Let's look at two areas where this head-of-line blocking issue is a huge deal.</p>
<p><strong>Multiplayer Game Networking</strong></p>
<p>Multiplayer action games are based on a constant stream of packets sent at a speed ranging from 10 to 30 packets per second.
For the most part, the data in these packages are so time-sensitive that only the most recent data is useful.
You can think of the input and position of the player, the orientation and speed, and the state of the physical objects in the world.
If a single packet drops out we can not afford to queue up 10-30 packets a second until the lost packet is retransmitted. 
This could cause annoying lag behavior and a bad user experience. </p>
<p><strong>Web Networking</strong></p>
<p>Game networking is not the only area where this head-of-line blocking is a big issue.
The World Wide Web is a place where quick web-page load speeds are important (who wants to wait 200ms to the long right?).
As websites get bigger and attention decreases, we need faster loading times for websites.</p>
<p>To tackle this issue, HTTP-2 introduced a technique called multiplexing. 
In short, this means that multiple TCP streams are initialized to communicate with the server. 
Then If one of them blocks the whole website can continue to load seemingly while that single stream is retransmitting.</p>
<p>We will take a deeper dive into this subject when looking at QUIC multiplexing.</p>
<h3><a class="header" href="#connection-setup-duration" id="connection-setup-duration">Connection Setup Duration</a></h3>
<p>In the standard HTTP+TLS+TCP stack, TCP needs a handshake to establish a session between server and client, 
and TLS needs its handshake to ensure that the session is secured.</p>
<p><img src="./images/tcp-handshake.svg.png" alt="TCP-handshake" /></p>
<p>First, the source sends an 'SYN initial request' packet to the target server to start the dialogue. 
Then the target server sends an 'SYN-ACK packet' to agree to the process.
Lastly, the source sends an 'ACK packet' to the target to confirm the process, after which the message exchange can start. </p>
<p>Now if we want to secure the TCP connection, we have to use a protocol like TLS on top of it. 
In the case of TLS versions older than 1.3, an additional three more handshake messages are required.</p>
<p>You can see how expensive it is to create a secure TCP connection. 
In a scenario of TCP and TLS 1.2 with a 100ms latency, we need to wait for 6 x 100ms = 600ms to set up a connection. 
If the website is big, an additional load time can make the website load over a second. 
This, of course, is disturbing for our short attention spans. </p>
<h3><a class="header" href="#requests-in-segment" id="requests-in-segment">Requests in Segment</a></h3>
<p>A TCP segment can only carry a single HTTP/1.1 Request/Response. 
Consequently, a large number of small segments may be sent within
an HTTP/1.1 session which can lead to overhead.</p>
<h3><a class="header" href="#client-connection-initiation" id="client-connection-initiation">Client Connection Initiation</a></h3>
<p>HTTP/1.1 transfers are always initiated by the client. 
This decreases the performance of HTTP/1.1 significantly when loading embedded files because a server has to
wait for a request from the client, even if the server knows
that the client needs a specific resource.</p>
<h1 align="center"><img width="500" src="./docs/thumbnail.svg" /></h1>
<p><a href="https://docs.rs/quinn/"><img src="https://docs.rs/quinn/badge.svg" alt="Documentation" /></a>
<a href="https://crates.io/crates/quinn"><img src="https://img.shields.io/crates/v/quinn.svg" alt="Crates.io" /></a>
<a href="https://github.com/djc/quinn/actions?query=workflow%3ACI"><img src="https://github.com/djc/quinn/workflows/CI/badge.svg" alt="Build status" /></a>
<a href="https://codecov.io/gh/djc/quinn"><img src="https://codecov.io/gh/djc/quinn/branch/main/graph/badge.svg" alt="codecov" /></a>
<a href="https://matrix.to/#/#quinn:matrix.org"><img src="https://img.shields.io/badge/chat-%23quinn:matrix.org-%2346BC99?logo=matrix" alt="Chat" /></a>
<a href="https://gitter.im/djc/quinn"><img src="https://badges.gitter.im/gitterHQ/gitter.svg" alt="Chat" /></a>
<a href="LICENSE-MIT"><img src="https://img.shields.io/badge/License-MIT-blue.svg" alt="License: MIT" /></a>
<a href="LICENSE-APACHE"><img src="https://img.shields.io/badge/License-Apache%202.0-blue.svg" alt="License: Apache 2.0" /></a></p>
<h1><a class="header" href="#pure-rust-quic-protocol-implementation" id="pure-rust-quic-protocol-implementation">Pure-rust QUIC protocol implementation</a></h1>
<p>Quinn is a pure-rust, future-based implementation of the <a href="https://quicwg.github.io/">QUIC</a> transport protocol undergoing standardization by the IETF.
This library is at <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-transport/29/">draft 32</a>.</p>
<h2><a class="header" href="#features" id="features">Features</a></h2>
<ul>
<li>Simultaneous client/server operation.</li>
<li>Ordered and unordered stream reads for improved performance.</li>
<li>Works on stable Rust, tested on Linux, macOS and Windows.</li>
<li>Pluggable cryptography, with a standard implementation backed by
<a href="https://github.com/ctz/rustls">rustls</a> and <a href="https://github.com/briansmith/ring"><em>ring</em></a>.</li>
<li>Application-layer datagrams for small, unreliable messages.</li>
<li>Future-based async API.</li>
<li>Experimental HTTP over QUIC.</li>
</ul>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<ul>
<li><strong>quinn:</strong> High-level async API based on tokio, see for usage. This will be used by most developers. (Basic benchmarks are included.)</li>
<li><strong>quinn-proto:</strong> Deterministic state machine of the protocol which performs <strong>no</strong> I/O internally and is suitable for use with custom event loops (and potentially a C or C++ API).</li>
<li><strong>quinn-h3:</strong> Contains an implementation of HTTP-3 and QPACK. It is split internally in a deterministic state machine and a tokio-based high-level async API.</li>
<li><strong>bench:</strong> Benchmarks without any framework.</li>
<li><strong>interop:</strong> Tooling that helps to run interoperability tests.</li>
<li><strong>fuzz:</strong> Fuzz tests.</li>
</ul>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p><strong>Examples</strong></p>
<pre><code class="language-sh">$ cargo run --example server ./
$ cargo run --example client https://localhost:4433/Cargo.toml
</code></pre>
<p>This launches an HTTP 0.9 server on the loopback address serving the current
working directory, with the client fetching <code>./Cargo.toml</code>. By default, the
server generates a self-signed certificate and stores it to disk, where the
client will automatically find and trust it.</p>
<p><strong>Links</strong></p>
<ul>
<li>Talk at <a href="https://paris.rustfest.eu/sessions/a-quic-future-in-rust">RustFest Paris (May 2018) presentation</a>; <a href="https://dirkjan.ochtman.nl/files/quic-future-in-rust.pdf">slides</a>; <a href="https://www.youtube.com/watch?v=EHgyY5DNdvI">YouTube</a></li>
<li>Usage <a href="https://github.com/djc/quinn/tree/main/quinn/examples">examples</a></li>
<li>Guide <a href="https://github.com/djc/quinn/issues/865">book</a></li>
</ul>
<h2><a class="header" href="#usage-notes" id="usage-notes">Usage Notes</a></h2>
<details>
<summary>
Click to show the notes
</summary>
<h3><a class="header" href="#buffers" id="buffers">Buffers</a></h3>
<p>A Quinn endpoint corresponds to a single UDP socket, no matter how many
connections are in use. Handling high aggregate data rates on a single endpoint
can require a larger UDP buffer than is configured by default in most
environments. If you observe erratic latency and/or throughput over a stable
network link, consider increasing the buffer sizes used. For example, you could
adjust the <code>SO_SNDBUF</code> and <code>SO_RCVBUF</code> options of the UDP socket to be used
before passing it in to Quinn. Note that some platforms (e.g. Linux) require
elevated privileges or modified system configuration for a process to increase
its UDP buffer sizes.</p>
<h3><a class="header" href="#certificates" id="certificates">Certificates</a></h3>
</details>
<p></p>
<h2><a class="header" href="#contribution" id="contribution">Contribution</a></h2>
<p>All feedback welcome. Feel free to file bugs, requests for documentation and
any other feedback to the <a href="https://github.com/djc/quinn/issues">issue tracker</a>.</p>
<p>The quinn-proto test suite uses simulated IO for reproducibility and to avoid
long sleeps in certain timing-sensitive tests. If the <code>SSLKEYLOGFILE</code>
environment variable is set, the tests will emit UDP packets for inspection
using external protocol analyzers like Wireshark, and NSS-compatible key logs
for the client side of each connection will be written to the path specified in
the variable.</p>
<h2><a class="header" href="#authors" id="authors">Authors</a></h2>
<ul>
<li><strong>Dirkjan Ochtman</strong> - <em>Project owner &amp; founder</em></li>
<li><strong>Benjamin Saunders</strong> - <em>Project owner &amp; founder</em></li>
<li><strong>Jean-Christophe Begue</strong> - <em>Project collaborator, author of the HTTP/3 Implementation</em></li>
</ul>
<p>In the next chapter we will go through the protocol using examples. 
The chapters are in order, first we look at configuring a certificate, then at setting up a connection and finally at sending data. </p>
<p>Contents:</p>
<ol>
<li><a href="quinn/certificate.html">Cryptography Setup</a></li>
<li><a href="quinn/set-up-connection.html">Connection Setup</a></li>
<li><a href="quinn/data-transfer.html">Data Transfer</a></li>
</ol>
<h1><a class="header" href="#certificates-1" id="certificates-1">Certificates</a></h1>
<p>In this chapter, we discuss the configuration of the certificates that is <strong>required</strong> for a working Quinn connection. </p>
<p>A <a href="https://en.wikipedia.org/wiki/Certificate_authority">Certificate Authority (CA)</a> is an entity that issues digital <a href="https://en.wikipedia.org/wiki/Public_key_certificate">certificates</a>. 
These digital certificates certify ownership of a public key associated with, for example, a host, server, client, or document.
Digital certificates ensure that users can be confident that the content actually comes from a reliable, secure source.</p>
<p><strong>By default</strong>, Quinn clients validate the cryptographic identity of the servers they connect to. 
This prevents an attacker from intercepting messages.
While it is great that quinn offers security by default it requires additional configuration.
This additional configuration will be the subject of this chapter. </p>
<h2><a class="header" href="#insecure-connection" id="insecure-connection">Insecure Connection</a></h2>
<p>A certificate is not practical for cases such as: peer-to-peer, trust-on-first-use,
deliberately insecure applications, or when the servers are not identified by the domain name. 
You can change certificate validation logic when the <code>dangerous_configuration</code> feature flag of <a href="https://github.com/ctz/rustls">rustls</a> is enabled.
Then the only thing that needs to be done is to configure the client to trust any server.</p>
<p>Start with adding a <a href="https://github.com/ctz/rustls">rustls</a> dependency with the <code>dangerous_configuration</code> feature flag to your <code>Cargo.toml</code> file.</p>
<pre><code class="language-toml">quinn = &quot;*&quot;
rustls = { version = &quot;*&quot;, features = [&quot;dangerous_configuration&quot;, &quot;quic&quot;] }
</code></pre>
<p>Then, you can skip the certificate validation on the client by implementing <a href="https://docs.rs/rustls/latest/rustls/trait.ServerCertVerifier.html">ServerCertVerifier</a> and let it assert true for any server. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Implementation of `ServerCertVerifier` that verifies everything as trustworthy.
struct SkipCertificationVerification;

impl rustls::ServerCertVerifier for SkipCertificationVerification {
    fn verify_server_cert(
        &amp;self,
        _roots: &amp;rustls::RootCertStore,
        _presented_certs: &amp;[rustls::Certificate],
        _dns_name: webpki::DNSNameRef,
        _ocsp_response: &amp;[u8],
    ) -&gt; Result&lt;rustls::ServerCertVerified, rustls::TLSError&gt; {
        Ok(ServerCertVerified::assertion())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>After that, we can configure our <a href="https://docs.rs/quinn/latest/quinn/generic/struct.ClientConfig.html">ClientConfig</a> to use this new <a href="https://docs.rs/rustls/latest/rustls/trait.ServerCertVerifier.html">ServerCertVerifier</a>. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn insecure() -&gt; ClientConfig {
    let mut cfg = quinn::ClientConfigBuilder::default().build();

    // Get a mutable reference to the 'crypto' config in the 'client config'..
    let tls_cfg: &amp;mut rustls::ClientConfig =
        std::sync::Arc::get_mut(&amp;mut cfg.crypto).unwrap();

    // Change the certification verifier.
    // This is only available when compiled with 'dangerous_configuration' feature.
    tls_cfg
        .dangerous()
        .set_certificate_verifier(Arc::new(SkipCertificationVerification));
    cfg
}
<span class="boring">}
</span></code></pre></pre>
<p>Finally, if you plug this <a href="https://docs.rs/quinn/latest/quinn/generic/struct.ClientConfig.html">ClientConfig</a> into the <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html#method.default_client_config">EndpointBuilder::default_client_config()</a> your client endpoint should verify all connections as trustworthy.</p>
<h2><a class="header" href="#using-certificates" id="using-certificates">Using Certificates</a></h2>
<p>In this section we look at certifying an endpoint with a real certificate. 
This can be done with either a real certificate or a self-identified certificate.</p>
<p>Let's define two useful functions that can dissect byte certificates and return quinn types.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn parse_der(cert: Vec&lt;u8&gt;, private_key: Vec&lt;u8&gt;) -&gt; anyhow::Result&lt;(quinn::Certificate, quinn::PrivateKey)&gt; {
    let cert = quinn::Certificate::from_der(&amp;cert)?;
    let key = quinn::PrivateKey::from_der(&amp;private_key)?;
    Ok((cert, key))
}

pub fn parse_pem(cert: Vec&lt;u8&gt;, private_key: Vec&lt;u8&gt;) -&gt; anyhow::Result&lt;(quinn::Certificate, quinn::PrivateKey)&gt; {
    // Parse to certificate chain whereafter taking the first certifcater in this chain.
    let cert = quinn::CertificateChain::from_pem(&amp;cert)?.iter().next().unwrap().clone();
    let key = quinn::PrivateKey::from_pem(&amp;private_key)?;

    Ok((quinn::Certificate::from(cert), key))
}
<span class="boring">}
</span></code></pre></pre>
<p>There are two common certificate formats namely: <code>.pem</code> and <code>.der</code>.
The <code>.der</code> certificates are byte-coded, while <code>.pem</code> is text-coded.
You can translate one to the other by using tooling such as openssl or even within code self. 
The code translation is shown above. </p>
<h3><a class="header" href="#self-signed" id="self-signed">Self Signed</a></h3>
<p>A <a href="https://en.wikipedia.org/wiki/Self-signed_certificate#:%7E:text=In%20cryptography%20and%20computer%20security,a%20CA%20aim%20to%20provide.">self-signed</a> certificate entails that you sign a certificate with your own CA. 
These certificates are easy to create and cost no money. 
However, they do not offer all the security features that certificates from a CA do have. 
Some ways to create a self-signed certificate is by using <a href="https://github.com/est31/rcgen">rcgen</a> or openssl. 
In this example <a href="https://github.com/est31/rcgen">rcgen</a> is used.</p>
<p>Let's look at an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn generate_self_signed_cert(cert_path: &amp;str, key_path: &amp;str) -&gt; anyhow::Result&lt;(quinn::Certificate, quinn::PrivateKey)&gt; {
    // Generate dummy certificate.
    let certificate = rcgen::generate_simple_self_signed(vec![&quot;localhost&quot;.into()]).unwrap();
    let serialized_key = certificate.serialize_private_key_der();
    let serialized_certificate = certificate.serialize_der().unwrap();

    // Write to files.
    fs::write(&amp;cert_path, &amp;serialized_certificate).context(&quot;failed to write certificate&quot;)?;
    fs::write(&amp;key_path, &amp;serialized_key).context(&quot;failed to write private key&quot;)?;

    parse_der(serialized_certificate, serialized_key)
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Note that <a href="https://docs.rs/rcgen/latest/rcgen/fn.generate_simple_self_signed.html">generate_simple_self_signed</a> returns a <a href="https://en.wikipedia.org/wiki/Public_key_certificate">Certificate</a> that can be serialized to both <code>.der</code> and <code>.pem</code> formats.</em></p>
<h3><a class="header" href="#official-certificates" id="official-certificates">Official Certificates</a></h3>
<p><a href="https://letsencrypt.org/getting-started/">Let's Encrypt</a> is a CA and distributes certificates for free. 
Its a very well-known CA used by many applications around the world.
We can cover a detailed lets-encrypt tutorial but there is plenty of good documentation out there.</p>
<p><strong>Generate Certificate</strong></p>
<p>Let's Encrypt works with <a href="https://certbot.eff.org/instructions">Certbot</a>, certbort generates the certificate for you.
Often a certificate is generated to secure a web server. 
Because we generate a certificate for a protocol, the configuration process will be slightly different than normal. 
We assume that you do not have a web server. 
Select on the certbot website that you do not have a web server and follow the given installation instructions.</p>
<p>If certbot is installed, execute <code>certbot certonly --standalone</code>, this command will fire up a web server in the background.
Certbot asks for your data, after entering it two <code>.pem</code> files are generated, namely <code>cert.pem</code> and <code>privkey.pem</code>. 
Next we can reference those files in the code.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Read from certificate and key from directory. 
let (cert, key) = fs::read(&amp;&quot;./cert.pem&quot;).and_then(|x| Ok((x, fs::read(&amp;&quot;./privkey.pem&quot;)?)))?;
// Parse bytes to type.
parse_pem(cert, key)
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#configuring-certificates" id="configuring-certificates">Configuring Certificates</a></h3>
<p>Now you generated, or maybe you already had, the certificate, they need to be configured into the client and server. 
After configuring plug the configuration into the <code>Endpoint</code>.</p>
<p><strong>Configure Server</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = ServerConfigBuilder::default();
builder.certificate(CertificateChain::from_certs(vec![certificate]), key)?;
<span class="boring">}
</span></code></pre></pre>
<p>This is the only thing you need to do for your sever to be secured. </p>
<p><strong>Configure Client</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut builder = ClientConfigBuilder::default();
builder.add_certificate_authority(certificate)?;    
<span class="boring">}
</span></code></pre></pre>
<p>This is the only thing you need to do for your client to be secured.</p>
<p><br><hr></p>
<p><a href="quinn/set-up-connection.html">Nextup</a>, lets look at how to setup a connection. </p>
<h1><a class="header" href="#connection-setup" id="connection-setup">Connection Setup</a></h1>
<p>In the <a href="quinn/certificate.html">previous chapter</a> we looked at how to configure a certificate.
This aspect is omitted in this chapter to prevent duplication. 
But keep <strong>remember</strong> that is is required to get your <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Endpoint.html">Endpoint</a> up and running. 
This chapter explains how to set up a connection and prepare it for data transfer. </p>
<p>It all starts with the <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Endpoint.html">Endpoint</a> struct, this is the entry of the library. </p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>Let's start by defining some constants. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static SERVER_NAME: &amp;str = &quot;localhost&quot;;

fn client_addr() -&gt; SocketAddr {
    &quot;127.0.0.1:5000&quot;.parse::&lt;SocketAddr&gt;().unwrap()
}

fn server_addr() -&gt; SocketAddr {
    &quot;127.0.0.1:5001&quot;.parse::&lt;SocketAddr&gt;().unwrap()
}
<span class="boring">}
</span></code></pre></pre>
<p>For both the server and the client we use the <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html">EndpointBuilder</a>. 
The <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html">EndpointBuilder</a> has a method <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html#method.bind">bind(address)</a> with which you link an address to the endpoint. 
This method initializes a UDP-socket that is used by quinn.
If you need more control over the socket creation, it is also possible to initialize a quinn endpoint with an existing UDP socket. 
For this use the method <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html#method.with_socket">with_socket</a>.</p>
<p><strong>Client</strong></p>
<p>Just like with a TCP client, you need to connect to a destination. 
In quinn you can do this with the method <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Endpoint.html#method.connect">connect()</a>. 
The <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Endpoint.html#method.connect">connect()</a> method has an argument 'server name', this is the name that is in the certificate. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn client() -&gt; anyhow::Result&lt;()&gt; {
    let mut endpoint_builder = Endpoint::builder();

    // Bind this endpoint to a UDP socket on the given client address.
    let (endpoint, _) = endpoint_builder.bind(&amp;client_addr())?;

    // Connect to the server passing in the server name which is supposed to be in the server certificate.
    let connection: NewConnection = endpoint
        .connect(&amp;server_addr(), SERVER_NAME)?
        .await?;

    // Start transferring, receiving data, see DataTransfer tutorial.

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Server</strong></p>
<p>Just like a TCP Listener, you have to listen to incoming connections. 
Before you can listen to connections you need to configure the <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html">EndpointBuilder</a> as a server.<br />
Note that the configuration itself does not perform any listening logic, this can only be done after you have run <a href="https://docs.rs/quinn/latest/quinn/generic/struct.EndpointBuilder.html#method.bind">bind()</a>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn server() -&gt; anyhow::Result&lt;()&gt; {
    let mut endpoint_builder = Endpoint::builder();
    // Configure this endpoint as a server by passing in `ServerConfig`.
    endpoint_builder.listen(ServerConfig::default());

    // Bind this endpoint to a UDP socket on the given server address. 
    let (endpoint, mut incoming) = endpoint_builder.bind(&amp;server_addr())?;

    // Start iterating over incoming connections.
    while let Some(conn) = incoming.next().await {
        let mut connection: NewConnection = conn.await?;

        // Save connection somewhere, start transferring, receiving data, see DataTransfer tutorial.
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#data-transfer" id="data-transfer">Data Transfer</a></h1>
<p>In the <a href="quinn/set-up-connection.html">previous chapter</a> we characterized how to set up an <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Endpoint.html">Endpoint</a>
and then get access to a <a href="https://docs.rs/quinn/latest/quinn/generic/struct.NewConnection.html">NewConnection</a> instance.
Now we will continue with the subject of sending data over this connection.</p>
<h2><a class="header" href="#multiplexing" id="multiplexing">Multiplexing</a></h2>
<p>A QUIC stream can be compared to a TCP stream, eventhough if it is based on UDP. 
The big difference is that you are not limited to a single stream. 
You can open multiple streams between two peers, this is also called multiplexing.</p>
<p>Stream multiplexing can have a significant positive effect on application performance if the resources allocated to streams are properly prioritized.
Currently it is used in a protocol like HTTP/2, but unlike HTTP multiplexing, QUIC does not automatically multiplexing data.
This is an advantage because the user gets full control over the multiplexing. 
In addition, QUIC is not limited to one kind of stream but can open both bidirectional and unidirectional streams.</p>
<h2><a class="header" href="#stream-types" id="stream-types">Stream Types</a></h2>
<p>Quinn offers three ways to send your data. 
Two stream-based and one message-based.</p>
<table><thead><tr><th align="left">Type</th><th align="left">Description</th><th align="left">Reference</th></tr></thead><tbody>
<tr><td align="left"><strong>Bidirectional Stream</strong></td><td align="left">two way stream communication.</td><td align="left">see <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Connection.html#method.open_bi">open_bi</a></td></tr>
<tr><td align="left"><strong>Unidirectional Stream</strong></td><td align="left">one way stream communication.</td><td align="left">see <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Connection.html#method.open_uni">open_uni</a></td></tr>
<tr><td align="left"><strong>Unreliable Messaging</strong></td><td align="left">message based unreliable communication.</td><td align="left">see <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Connection.html#method.send_datagram">send_datagram</a></td></tr>
</tbody></table>
<p>Soon we will discuss this in more detail.</p>
<h2><a class="header" href="#how-to-use" id="how-to-use">How to Use</a></h2>
<p>You can open a new stream or read from an existing stream of data.
New streams can be created with the methods <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Connection.html#method.open_bi">open_bi</a>, <a href="https://docs.rs/quinn/latest/quinn/generic/struct.Connection.html#method.open_uni">open_uni</a> from <a href="https://docs.rs/quinn/latest/quinn/generic/struct.NewConnection.html#structfield.connection">Connection</a> type.
An instance of this type is found in the <a href="https://docs.rs/quinn/latest/quinn/generic/struct.NewConnection.html#structfield.connection">connection</a> field of <a href="https://docs.rs/quinn/latest/quinn/generic/struct.NewConnection.html">NewConnection</a>. 
This <a href="https://docs.rs/quinn/latest/quinn/generic/struct.NewConnection.html">NewConnection</a> stores existing streams as well. Lets look at some examples:</p>
<p><em>Iterate over various opened streams</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn iterate_streams(mut connection: NewConnection) -&gt; anyhow::Result&lt;()&gt; {
    // Iterate unidirectional streams with only the receiving side.
    while let Some(Ok(recv)) = connection.uni_streams.next().await { }
    // Iterate bidirectional streams with both sent and receiving side.
    while let Some(Ok((sent, recv))) = connection.bi_streams.next().await { }
    // Iterate arrived datagrams.
    while let Some(Ok(bytes)) = connection.datagrams.next().await { }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>Open different types of streams</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn open_streams(mut connection: Connection) -&gt; anyhow::Result&lt;()&gt; {
    // Open unidirectional stream.
    let mut send = connection.
        open_uni()
        .await?;

    // Open bidirectional stream.
    let (send, recv) = connection.
        open_bi()
        .await?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#bidirectional-streams" id="bidirectional-streams">Bidirectional Streams</a></h2>
<p>With bidirectional streams you can carry data in both directions, for example, from the initiator to the peer and in reverse.</p>
<p><em>open bidirectional stream</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn open_bidirectional_stream(connection: Connection) -&gt; anyhow::Result&lt;()&gt; {
    let (mut send, recv) = connection.
        open_bi()
        .await?;

    send.write_all(b&quot;test&quot;).await?;
    send.finish().await?;
    
    let received = recv.read_to_end(10).await?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>iterate bidirectional stream(s)</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn receive_bidirectional_stream(mut connection: NewConnection) -&gt; anyhow::Result&lt;()&gt; {
    while let Some(Ok((sent, recv))) = connection.bi_streams.next().await {
        // Because it is a bidirectional stream, we can both sent and recieve.
        println!(&quot;request: {:?}&quot;, recv.read_to_end(50).await?);

        send.write_all(b&quot;response&quot;).await?;
        send.finish().await?;
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unidirectional-streams" id="unidirectional-streams">Unidirectional Streams</a></h2>
<p>With unidirectional streams, you can carry data only in one direction, for example, from the initiator of the stream to its peer.</p>
<p><em>open unidirectional stream</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn open_unidirectional_stream(connection: Connection)-&gt; anyhow::Result&lt;()&gt; {
    let mut send = connection.
        open_uni()
        .await?;

    send.write_all(b&quot;test&quot;).await.unwrap();
    send.finish().await?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>iterating unidirectional stream(s)</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn receive_unidirectional_stream(mut connection: NewConnection) -&gt; anyhow::Result&lt;()&gt; {
    while let Some(Ok(recv)) = connection.uni_streams.next().await {
        // Because it is a unidirectional stream, we can only receive not sent back.
        println!(&quot;{:?}&quot;, recv.read_to_end(50).await?);
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unreliable-messaging" id="unreliable-messaging">Unreliable Messaging</a></h2>
<p>With unreliable messaging you can transfer data <a href="quinn/../network-introduction/transport-guarantees.html">unreliable</a> over bare UDP.</p>
<p><em>send datagram</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn sent_unreliable(connection: Connection)-&gt; anyhow::Result&lt;()&gt; {
    connection.
        send_datagram(b&quot;test&quot;.into())
        .await?;

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><em>iterating datagram stream(s)</em></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn receive_datagram(mut connection: NewConnection) -&gt; anyhow::Result&lt;()&gt; {
    while let Some(Ok(receivedBytes)) = connection.datagrams.next().await {
        // Because it is a unidirectional stream, we can only receive not sent back.
        println!(&quot;request: {:?}&quot;, received);
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#quic-introduction" id="quic-introduction">QUIC Introduction</a></h1>
<p>QUIC is a general-purpose, transport layer, network protocol, built on top of UDP.
It is still an internet <a href="https://datatracker.ietf.org/doc/draft-ietf-quic-transport/">draft</a> undergoing standardization by the IETF.
This indicates that it is not yet stabilized. 
Quinn focuses on satisfying the latest draft but may lag some drafts behind. 
The fact that it is a draft does not detract from the fact that QUIC is already used by more than half of 
all connections from Chrome web browsers to Google's servers with increasing adoption in the overall market. </p>
<p>QUIC aims to be nearly equivalent to a TCP connection. With the goals to improve the performance of connection-oriented web applications, 
reduce connection and transport latency, and estimate bandwidth for better congestion control. 
While the intentions of QUIC were original web-oriented, it suits other areas like the game-networking industry very well.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
